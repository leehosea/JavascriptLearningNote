### 3. 操作符
#### 3.1 一元操作符

只能操作**一个值**的操作符叫**一元操作符**

#####3.1.1 递增(++)、递减(--)操作符
ECMAScript的递增递减操作符借鉴自C语言，并且各自有两个版本：**前置**和**后置**。  
前置型，操作符位于变量前  
后置型，操作符位于变量后  
>	var num = 10;  
>	++num;  //前置递增  
>	num++;  //后置递增  
>	--num;  //前置递减  
>	num--  //后置递减  

执行含有前置递增或递减操作时，变量的值都是在当前语句被求值前改变，且改变变量值本身有效，例如：  
>	var num = 10;  
>	var num1 = ++num + 5;  //输出 16
>	var num2 = num + 5;  //输出 16

上例中，第二行语句，在对语句求值前，num先进行递增操作(num = num + 1)，num此时等于11，然后对语句求值(11 + 5)。第三行在求值时，此时num等于第二行递增操作后的值，num等于11。

后置型与前置型的区别在于，语句求值后再执行递增或递减操作。例如：  
>	var num = 10;  
>	var num1 = num-- + 5;  //输出15  
>	var num2 = num + 5;  //输出14

递增和递减操作符适用于任何值，也就是说它不仅仅只适用于整数数值，**它还适用于字符串、布尔值、浮点数值和对象**。其对不同类型变量遵循下列规则：  
* 在应用于一个包含有效数字字符串时，先将其转换为数字值，再执行递增或递减操作，并且字符串变量转换为数值变量。  
* 在应用于一个不包含有效数字字符时，将变量的值设置为NaN，并且字符串变量转换为数值变量。  
* 在应用于布尔值false时，先将其转换为0，再执行递增或递减操作，并且布尔型变量转换为数值变量。  
* 在应用于布尔值true时，先将其转换为1，再执行递增或递减操作，并且布尔型变量转换为数值变量。  
* 在应用于浮点数值时，执行递增或递减操作。  
* 在应用于对象时，先调用对象的valueOf()方法，取得一个可供操作的值，然后对该值应用前述规则。如果结果是NaN，则再调用toString()方法后再应用前述规则一次。对象变量变成数值变量。

请看例子：
>	var s1 = "2";  
>	var s2 = "123abc";  
>	var b = false;  
>	var f = 1.1;  
>	var o = {  
>		&nbsp;valueOf : function(){  
>			&nbsp;&nbsp;return -1;  
>		&nbsp;}  
>	};  
>	s1++;  //值变为数值3  
>	s2++; // 值变为数值NaN  
>	b++;  //  值变为数值1  
>	f--;  //值变为数值0.10000000000000009,浮点舍入错误的问题。  
>	o--;  // 值变为数值-2

#####3.1.2 一元操作符： 加(+) 和 减(-)  
一元加减操作符同数学加减符号，该操作符放在变量前不会对变量产生任何影响：  
>	var num = 25;  
>	num = +num;  //num还是25  

在对非数值应用加（＋）操作符时，该操作符会像Number()转型函数一样对这个值执行转换，布尔false和true被转为0和1，字符串会按照特定规则进行解析并转换，而对象是先调用他们的valueOf()和（或）toString()方法，再转换得到的值。例如：  
>	var s1 = "01";  
>	var s2 = "1.1";  
>	var s3 = "z";  
>	var b = false;  
>	var f = 1.1;  
>	var o = {  
>	&nbsp;&nbsp;valueOf:{  
>	&nbsp;&nbsp;&nbsp;&nbsp;return -1;  
>	&nbsp;&nbsp;}  
>	};  
>	s1 = +s1; //值变成数值1    
>	s2 = +s2;  //值变成数值1.1  
>	s3 = +s3;  //值变成NaN  
>	b = +b;  //值变成0  
>	f = +f;  //值未变，仍然是1.1  
>	o = +o; //值变成数值－1  

一元减操作符（－）主要用于表示负数。在对非数值应用减（－）操作符时，先按照一元加（＋）操作符做转换，然后将得到的数值转换为负数。例如：  
>	var s1 = "01";  
>	var s2 = "1.1";  
>	var s3 = "z";  
>	var b = false;  
>	var f = 1.1;  
>	var o = {  
>	&nbsp;&nbsp;valueOf:{  
>	&nbsp;&nbsp;&nbsp;&nbsp;return -1;  
>	&nbsp;&nbsp;}  
>	};  
>	s1 = -s1; //值变成数值-1    
>	s2 = -s2;  //值变成数值-1.1  
>	s3 = -s3;  //值变成NaN  
>	b = -b;  //值变成0  
>	f = -f;  //值未变，仍然是-1.1  
>	o = -o; //值变成数值1  

 
#####3.1.3  位操作符
位操作符是按照内存中表示数值的位来操作数值。ECMAScript中所有的数值都以IEEE-754 64位格式存储，而位操作符并不直接操作64位的值，而是先转换为32位的整数，然后执行位操作，最后再转换回64位的值。  

`有符号`的整数，32位中的前31位用于表示整数，第32位用于表示数值的符号：`0表示整数，1表示负数`。表示符号的位叫做**符号位**，其中正数以纯二进制格式存储，31位中的每一位表示2的幂。第一位（称为位0）表示2⁰，第二位表示2¹，以此类推。没有用到的位以0填充，例如18的二进制表示是10010（省略前面无效的0），计算方法如下：
>	//从位0开始  
>	位0 : 2⁰x0 = 0  
>	位1 : 2¹x1 = 2  
>	位2 : 2²x0 = 0  
>	位3 : 2³x0 = 0  
>	位4 : 2⁴x1 = 16  
>	0 + 2 + 0 + 0 + 16 = 18  

负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，有下列步骤：  
1.	求这个数值的绝对值的二进制码（－18先求18的二进制码）  
2.	求二进制反码，即将0替换为1，1替换为0  
3.	得到的二进制反码加1

例如，求-18的二进制码如下：
>	先求18的二进制码：  
>	0000 0000 0000 0000 0000 0000 0001 0010 
>	然后求其二进制反码，即0 1互换：  
>	1111 1111 1111 1111 1111 1111 1110 1101  
>	最后，二进制反码加1:  
>	1111 1111 1111 1111 1111 1111 1110 1101  + 1:  
>	1111 1111 1111 1111 1111 1111 1110  1110  

这样就求的了－18的二进制表示。**注意：在处理有符号整数时，是不能访问位31的，因为位31表示正负符号**  
ECMAScript会隐藏这些信息，在以二进制字符串形式输出一个负数时，我们看到的只是这个负数绝对值的二进制码前面加上了一个负号，如：  
>	var num = -18;  
>	console.log(num.toString(2));  //"-10010"  

如果对非数值应用位操作符，会先用Number()函数将该值转换为一个数值，然后再应用位操作，得到的结果将是一个数值。

######3.1.3.1 按位非(NOT)
按位非操作符用一个波浪线符号表示(~)，执行按位非的结果就是返回数值的反码。按位非是ECMAScript操作符中少数几个与二进制计算有关的操作符之一，看下面例子：  
>	var num1 = 25;  
>	var num2 = ~num1;  
>	//num1 二进制表示：0000 0000 0000 0000 0000 0000 0001 1001  
>	//num2 二进制表示：1111 1111 1111 1111 1111 1111 1110 0110  
>	console.log(num2) //输出 －26  

这里对25执行按位非操作，结果得到-26，这也验证了`按位非操作的本质：操作数的负值减1。`  

######3.1.3.2 按位与(AND)  
按位与操作符用一个和符号(&)表示。它需要两个操作符数。对同位的值的操作规则如下：  

第一个数值的位 | 第二个数值的位 | 结果  
-----|-----|-----  
1|1|1  
1|0|0  
0|1|0  
0|0|0  
例：  
>	var result = 25 & 3;  
>	console.log(result)  //1

操作过程如下：  
>	 　25 = 0000 0000 0000 0000 0000 0000 0001 1001  
>	　&nbsp;&nbsp;3 = 0000 0000 0000 0000 0000 0000 0000 0011  
>	 AND  = 0000 0000 0000 0000 0000 0000 0000 0001  

######3.1.3.3 按位或(OR)
按位或操作符由一个竖线符号(|)表示，同样也有两个操作数，遵循下列规则：  

第一个数值的位 | 第二个数值的位 | 结果  
-----|-----|-----  
1|1|1  
1|0|1  
0|1|1  
0|0|0

例：  
>	var result = 25 | 3;  
>	console.log(result)  //27 

操作过程如下：  
>	 　25 = 0000 0000 0000 0000 0000 0000 0001 1001  
>	　&nbsp;&nbsp;3 = 0000 0000 0000 0000 0000 0000 0000 0011  
>	 &nbsp;&nbsp;OR  = 0000 0000 0000 0000 0000 0000 0001 1011 

######3.1.3.4 按位异或(XOR)
按位异或操作符由一个插入符号(^)表示，也有两个操作值，遵循下列规则：  

第一个数值的位 | 第二个数值的位 | 结果  
-----|-----|-----  
1|1|0  
1|0|1  
0|1|1  
0|0|0

按位异或只有一个1时，才返回1，如果对应两位都是1或者0，则返回0。  
例：    
>	var result = 25 ^ 3;  
>	console.log(result)  //26

操作过程如下：  
>	 　25 = 0000 0000 0000 0000 0000 0000 0001 1001  
>	　&nbsp;&nbsp;3 = 0000 0000 0000 0000 0000 0000 0000 0011  
>	 XOR  = 0000 0000 0000 0000 0000 0000 0001 1010 

######3.1.3.5 左移  
左移操作符由两个小于号(<<)表示，这个操作符会将数值的所有位移动指定的位数。例如，如果将数值2（二进制码10）向左移动5位，结果就是64（二进制码1000000），如下：  
>	var oldValue = 2;  
>	var newValue = oldValue << 5;  

左移后，右侧多出5个空位，以0填充。`注意：左移不会影响操作符数的符号位，如果将-2左移5位，结果是-64`。  

######3.1.3.6 有符号右移 
有符号的右移操作符由两个大于号(>>)表示，这个操作符会将数值向右移动，但保留符号位。有符号右移与左移操作正好相反，即如果将64向右移5位，结果变回2：  
>	var oldValue = 64;  
>	var newValue = oldValue >> 5; // 2  

同样，在位移过程中，原数值中也会出现空位，只不过空位出现在原数值的左侧、符号位的右侧，ECMAScript会用符号位来填充空位。

-|位31|位30|位29|位28|位27|位26|位25|位24|位23|位22|位21|位20|位19|位18|位17|位16|位15|位14|位13|位12|位11|位10|位9|位8|位7|位6|位5|位4|位3|位2|位1|位0|
-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
数值64|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|0|0|
向右移动5位|0|空位|空位|空位|空位|空位|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|
填充空位|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|

######3.1.3.7 无符号右移
无符号右移由3个大于号(>>>)表示，这个操作符会将数值所有32位都向右移动。对正数来说，无符号右移的结果与有符号右移的结果相同。仍以前面有符号右移的代码为例，如将64无符号右移5位，结果仍然是2:  
>	var oldValue = 64;  
>	var newValue = oldValue >>> 5;  //2  

但对负数来说，情况就不一样了，首先，无符号右移是以0来填充空位，而不像有符号右移以符号位来填充。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，负数以其绝对值的二进制补码形式表示，因此会导致无符号右移后的结果非常之大，如：  
>	var oldValue = -64;  
>	var newValue = oldValue >>> 5; //134217726  

这里，对－64无符号右移5位，得到134217726，结果值非常大，因为：  
>	　　&nbsp;-64 = 1111 1111 1111 1111 1111 1111 1100 0000  
>	右移5位 ＝ 0000 0111 1111 1111 1111 1111 1111 1110 

#####3.1.4  布尔操作符
布尔操作符有三个：
1. 非(NOT)
2. 与(AND)
3. 或(OR)

###### 3.1.4.1逻辑非
逻辑非由一个叹号(!)表示，可以应用于ECMAScript中的任何值。无论这个值是什么类型，都会返回一个布尔值。逻辑非操作符会先将操作数转换为布尔值，再对其求反。规则如下：

* 如果操作数是一个对象，返回false  
* 如果操作数是空字符串，返回true  
* 如果操作数是非空字符串，返回false
* 如果操作数是数值0，返回true
* 如果操作数是任意非0数值，包括Infinity，返回false
* 如果操作数是null， 返回true
* 如果操作数是NaN，返回true
* 如果操作数是undefined，返回true


逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为。其中第一个逻辑非操作符会基于无论什么操作数都返回一个布尔值，第二个逻辑非操作值则对该布尔值求反，于是就得到了一个真正的布尔值。最终结果与这个值使用Boolean()转型函数相同

###### 3.1.4.2逻辑与
逻辑与操作符由两个和号(&&)表示，需要两个操作数。逻辑与的真值表如下： 

第一个操作数|第二个操作数|结果
-|-|-|
true | true | true
true | false | false
false | true | false
false | false | false

逻辑与操作可以应用于任何类型的操作数。在又一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，其遵循如下规则：

* 如果两个操作数都是对象， 则返回第二个操作数
* 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下，才会返回第二个对象
* 如果第一个操作数是对象，则返回第二个操作数
* 如果有一个操作数是null， 则返回null
* 如果有一个操作数是NaN，则返回NaN
* 如果有一个操作数是undefined，则返回undefined

`逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值。对于逻辑与操作来说，如果第一个操作数是false，那么第二个操作数无论是什么值，最终结果都不可能是true了`

看下面例子：
>	var found = true;  
>	var result = found && aUndefinedVariable;  //代码执行到这里会报错
>	console.log(result);  //代码不会执行到这里，因为上面报错了

上面例子中，执行到第二行会中断代码执行并报错，因为变量`aUndefinedVariable`没有声明。由于found是true，所以逻辑与操作符会继续对变量`aUndefinedVariable`求值。但变量`aUndefinedVariable`此时未定义，因此会导致错误。这就说明不能在逻辑与操作中使用未定义的值。如果将found赋值为false，则代码会继续执行下去，因为逻辑与不会对`aUndefinedVariable`进行求值了。但这样的代码不健全，不建议这样写。

###### 3.1.4.3逻辑或
逻辑或操作符由两个竖线(||)表示，需要两个操作数。逻辑或的真值表如下：

第一个操作数|第二个操作数|结果
-|-|-|
true | true | true
true | false | true
false | true | true
false | false | false

与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。其遵循如下规则：  

* 如果两个操作数都是对象， 则返回第一个操作数
* 如果第一个操作数是对象，则返回第一个操作数
* 如果第一个操作数的求值结果是false，则返回第二个操作数
* 如果有两个个操作数都是null， 则返回null
* 如果有两个操作数是NaN，则返回NaN
* 如果有一个操作数是undefined，则返回undefined

与逻辑与操作相似，逻辑或也是短路操作符，第一个操作数的求值结果为true，就不会对第二个操作数求值：
>	var found = true;
>	var result = ( found || aUndefinedVariable) //不会发生错误  
>	console.log(result) // true

虽然变量`aUndefinedVariable`没有定义，但是执行代码不会报错，因为found为true，就不会再对第二个操作数求值。如果found改为false，那么逻辑或操作符会继续对第二个操作数求值，由于`aUndefinedVariable`尚未定义，代码会中断执行并报错。

利用逻辑或的这一行为，我们可以为避免为变量赋值null或undefined，例如：  
>	var myObject = preferredObject || backupObject;

上面代码会中，如果preferredObject的值不是null或undefined，则会优先赋值给myObject，否则会将backupObject赋值给myObject。ECMAScript程序中会经常使用这种模式给变量赋值以确保变量值有效。

#####3.1.5  乘性操作符
ECMAScript定义了三个乘性操作符：  
1. 乘法  
2. 除法  
3. 求模

这三个操作符与Java等语言中的相似，只不过在对非数值做操作时，会自动进行类型转换。如果操作数不是数值，会先使用Number()转型函数将其转换为数值，也就是说，空字符串当作0，布尔值true当做1。

###### 3.1.5.1 乘法
乘法由一个星号(*)表示。在处理特殊值的情况下，乘法遵循如下规则：  

* 如果两个操作数都是数值，执行常规的乘法计算。如果结果超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity
* 如果一个操作数是NaN，则返回NaN
* 如果是Infinity与0相乘，则结果是NaN
* 如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号
* 如果是Infinity与Infinity相乘，则结果是Infinity
* 如果有一个操作数不是数值，则调用Number()转型函数，将其转为数值型，在应用上面的规则

###### 3.1.5.2 除法
除法由一个斜线符号(/)表示。除法遵循如下规则：

* 如果操作数都是数值，执行常规的除法计算。如果结果超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity
* 如果有一个操作数是NaN，则结果是NaN
* 如果是Infinity被Infinity除，则结果是NaN
* 如果是零被零除，则结果是NaN
* 如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。
* 如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号。
* 如果有一个操作数不是数值，则调用Number()转型函数，将其转为数值，然后再应用上面的规则。


###### 3.1.5.3 求模
求模（余数）操作符由一个百分号(%)表示。求模遵循如下规则：  

* 如果操作数都是数值，执行常规的除法计算，返回除得的余数
* 如果被除数是无穷大值而除数是有限大的数值，则结果是NaN
* 如果被除数是有限大数值而除数是零，则结果是NaN
* 如果是Infinity被Infinity除，则结果是NaN
* 如果被除数是有限大的数值，而除数是无穷大的数值，则结果是被除数
* 如果被除数是零，则结果是零
* 如果有一个操作数不是数值，则调用Number()转型函数，将其转为数值，然后再应用上面的规则。


#####3.1.6  加性操作符
###### 3.1.6.1 加法
加法操作符(+)的用法如下：
如果两个操作符都是数值，执行常规计算，然后根据下列规则返回结果：

* 如果有一个操作数是NaN，则结果是NaN
* 如果是Infinity加Infinity，则结果是Infinity
* 如果是-Infinity加-Infinity，则结果是-Infinity
* 如果是Infinity加-Infinity，则结果是NaN
* 如果是+0加+0，则结果是+0
* 如果是-0加-0，则结果是-0
* 如果是+0加-0，则结果是+0

如果有一个操作数是字符串，那么就要应用如下规则：

* 如果两个操作数都数字符串，则将第二个操作数与第一个操作数拼接起来
* 如果只有一个操作数是字符串，则将另外一个操作数转换为字符串，然后再将两个字符串拼接起来

如果有一个操作数是对象、数值、或布尔值，则调用他们的valueOf()方法，取得对应的字符串值，然后再应用前面的关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串"undefined"和"null"。

举几个例子：

>	var result = 5 + 5; //两个数值相加  
>	console.log(result); //输出数值10  
>	var result2 = 5 + "5"; //一个数值加字符串  
>	console.log(result2); //输出字符串'55'  

忽视加法操作符中的数据类型是ECMAScript中常见的错误，比如：  
>	var num1 = 5;  
>	var num2 = 10;  
>	var message = "The sum of 5 and 10 is  " + num1 + num2;  
>	console.log(message); //输出字符串"The sum of 5 and 10 is  510"  

上面的例子最后并没有输出正确的加法结果，而是输出了字符串"510"，为了避免这样的错误，需要先对数值进行计算，再做字符串拼接：  
>	var message = "The sum of 5 and 10 is  " + (num1 + num2);  
>	console.log(message); //输出字符串"The sum of 5 and 10 is  15"  

###### 3.1.6.2 减法
减法操作符(-)的用法如下：

* 如果两个操作符都是数值，则执行常规计算，并返回结果
* 如果有一个操作数是NaN，则结果是NaN
* 如果是Infinity减Infinity，则结果是NaN
* 如果是-Infinity减-Infinity，则结果是NaN 
* 如果是Infinity减-Infinity，则结果是Infinity
* 如果是-Infinity减Infinity，则结果是-Infinity
* 如果是+0减+0，则结果是+0
* 如果是+0减-0，则结果是-0
* 如果是-0减-0，则结果是+0
* 如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换结果是NaN，则减法的结果就是NaN
* 如果有一个操作数是对象，则调用对象的valueOf()方法取得表示该对象的数值。如果得到的数值是NaN，则减法结果是NaN。如果对象没有 valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。

看下面几个例子：
>	var result1 = 5 - true; //4, 因为true被转换为1  
>	var result2 = NaN -1; //NaN  
>	var result3 = 5 - 3; //2  
>	var result4 = 5 - ""; //5，因为空字符串转换为0  
>	var result5 = 5 - "2"; //3， 因为字符串"2"被转换为数值2  
>	var result5 = 5 - null; //5, 因为null转换为0









